# Mock-to-Real Development Guidelines

이 문서는 상용 수준의 프로젝트 신뢰성을 확보하기 위해 **Mock 데이터 기반 개발에서 실제 통신 흐름으로 전환**하는 고도화된 아웃라인을 정의합니다.

## 1. 핵심 전략: Interface-Driven Development
- 프로젝트의 모든 외부 통신(API, DB, 외부 서비스)은 인터페이스를 먼저 정의한다.
- 특정 라이브러리에 의존하지 않는 **수동 Mocking(Manual Mocking)**을 기본으로 하여 도구 중립성과 제어력을 유지한다.

## 2. 개발 단계 (Phases)

### Phase 1: Interface & Failure Modeling
- **요구사항 분석**: 상용 환경에서 발생할 수 있는 모든 성공/실패 시나리오를 식별한다.
- **데이터 모델링**: 성공 페이로드뿐만 아니라, 에러 응답(4xx, 5xx), 타임아웃, 네트워크 지연 등의 실패 모델을 정의한다.
- **인터페이스 확정**: 명세에 따라 실제 코드에서 사용할 추상 타입/인터페이스를 선언한다.

### Phase 2: Manual Mocking & Test Registry
- **Mock 구현**: 정의된 인터페이스를 구현하는 Mock 클래스/함수를 작성한다.
- **Mocking 리스트 관리**: `docs/backlog/` 또는 테스트 디렉토리 내에 Mocking된 인터페이스 리스트를 관리하여 누락을 방지한다.
- **테스트 케이스 매핑**: 각 Mock은 최소 1개 이상의 성공 케이스와 주요 실패 케이스(예: 데이터 없음, 권한 오류)를 검증하는 테스트 코드를 수반해야 한다.
- **Failure 조작**: 개발 단계에서 실패 상황을 쉽게 재현할 수 있도록 Mock 구현체 내부에 상태 제어(Error Injector 등) 기능을 포함한다.

### Phase 3: Integration & Real-Flow Transition
- **구현체 교체**: Dependency Injection(DI) 또는 Config를 통해 Mock 구현체를 실제 통신 구현체로 교체한다.
- **규격 검증**: 실제 시스템에서 내려오는 데이터가 Mock 정의 단계에서 수립한 데이터 모델과 일치하는지 런타임 또는 테스트 레벨에서 검토한다.

### Phase 4: Production Verification
- **부하 및 예외 검증**: 상용 환경과 유사한 조건에서 대량의 데이터 처리 및 연속적인 실패 상황에서의 시스템 복구력을 확인한다.

## 3. Mock 관리 규칙
1. **독립성**: Mock 데이터는 소스 코드와 분리된 별도의 디렉토리(예: `tests/mocks/`)에서 관리한다.
2. **현행화**: API 명세(RFC/Spec)가 변경되면 Mock 데이터와 테스트 케이스를 즉시 업데이트한다.
3. **민감 정보**: Mock 데이터 내에 실제 사용자의 민감 정보를 절대 포함하지 않는다.

---
**최종 업데이트**: 2026-01-17
